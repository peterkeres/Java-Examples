# Assignment 2: Linked Lists
 
Create a class that maintains the top scores for a video game using a **linked list**. For this project, you will create a linked list of **Base_Code.GameEntry objects**.

The provided classes are: 
- the Base_Code.GameEntry class (You can read more about the Base_Code.GameEntry class [here](http://cs.slu.edu/~goldwasser/dsaj/docs/index.html?dsaj/arrays/GameEntry.html))
- the Base_Code.Node Class. 

>Read them carefully. Notice that the Base_Code.Node class contains a Base_Code.GameEntry field!

### Part A (50%): Single Linked List. 

Start by creating a single linked list to use as your data structure for this task, in addition to the head field, you will also maintain a tail field. Create a new class that extends your single linked list class, which you should call **Single_Linked_List.HiScoresLL**. Include the below standard linked list features/methods in the Single_Linked_List.HiScoresLL class. Code up all the method headers exactly as given below.

#### Basic features of Single_Linked_List.HiScoresLL:

- head and size fields, which we learned about in class and reading
- A tail field that references the last node in the list (akin to the head field) Keep in mind
    - This field must be used/maintained/updated during operations like removing and adding nodes in case the last (or only) node is removed or a new node is being added to the end of the list.
    - Keep in mind the end of the list could be the same as the beginning of the list if there is only one item in it.
    - It is initially set to null, when the list is empty, just like the head field.
- A constructor method – creates a new empty linked list

```Java
/**
* Constructor that creates an empty list
*/
public Single_Linked_List.HiScoresLL() { }
```

- A display() method 
    - outputs all the high score entries in the list. 

```Java
/**
* Prints out all the game entries in the linked list
*/
public void display(){ }
```

• An addFirst(Base_Code.Node v) method – adds the node v to the front of the list
```Java
/**
* Add a node to the head of the list
* @param v
* the Base_Code.Node object to be added
*/
public void addFirst(Base_Code.Node v){ }
```

• A removeFirst() method – removes a node from the front of the list
```Java
/**
* Removes the first node and returns it,
* this method assumes the list is non-empty
* @return
* the Base_Code.Node that was removed
*/
public Base_Code.Node removeFirst(){ }
```

• An addLast(Base_Code.Node v) method – adds the node v to the end of the list.
```Java
/**
* Add a node to the tail of the list
* @param v
* the Base_Code.Node object to be added
*/
public void addLast(Base_Code.Node v){ }
```

Code up all the method headers with preceding comments exactly as given above. These headers are formatted in a specific way to allow for some nifty automatic creation of .html (web page) documentation for your class. This web page documentation for your program can be instantly generated by simply using the command: 
> javadoc Single_Linked_List.HiScoresLL.java 

at the command prompt. After running this command, you’ll see the .html document appear in the same directory as your .java files.

In implementing these next two methods, you may make calls to the basic list manipulation methods you created above.

• An add(Base_Code.GameEntry e) method, which only needs to work properly when the items in the list are already ordered by high score as expected
```Java
/**
* Assuming the list of game entries is in decreasing order by score,
* this method creates a Base_Code.Node with the given Base_Code.GameEntry e, and then
* inserts it in the appropriate spot in the list.
* @param e
* the Base_Code.GameEntry object to be added to the list
*/
public void add(Base_Code.GameEntry e){ }
```

• remove(int i) removes the ith node, returning the corresponding game entry object
```java
/**
* Removes the node at position i in the list
* (emulating an array index)
* @return
* the Base_Code.GameEntry of the removed node
* or null if position i is invalid
*/
public Base_Code.GameEntry remove(int i){ }
```

### Part B (20%): Double Linked List. 
Create a second program that achieves the same goal as your first one, but uses a double-linked list rather than a single-linked list. You will need to first create a **Double_Linked_List.DNode class**, which you can base on the Base_Code.Node class, that will have an extra field *(called prev)* for the backward pointer. Double_Linked_List.DNode is the class you will use to build your double linked list. The name of your doubly-linked list class should be **Double_Linked_List.HiScoresDLL** and it should be saved in a file called Double_Linked_List.HiScoresDLL.java.

For this program, you needn’t write all the “basic functionality” methods that you did for the single-linked list. So, after creating the fields and the constructor method, you can go directly to writing the add(Base_Code.GameEntry e) and remove(int i) methods.

**Warning**: you might be tempted to try copying and pasting from the methods you wrote above, then modifying the code. However, these methods in a doubly-linked list class are significantly different, and more streamlined. You should write them from scratch rather than confuse things by trying to reuse old code. If you find yourself creating code that seems more unwieldy or complicated than the corresponding code for Part A, then you are going in the wrong direction. Part B’s code, done well, should be much more compact and elegant, not less. (No special cases needed!)

### Part C (20%): Final Challenge. 
Devise a simple (or not-so-simple) game that the Game.player can play from the basic command-line interface that tracks players’ high scores. The rules of the game are completely up to you, so I encourage you to (at least at first) keep it extremely basic, then you can make it more interesting if you have extra time. The only requirement of the game is that after each time the game is played, you must use the high scores class that you wrote in Part A or Part B to maintain a list of high scores. The game should start with a main menu that prompts the user to either “a) play a new game,” “b) see high scores,” or “c) shut down game.” Option c) simply ends the program. After each time a Game.player plays your game, update the high scores appropriately by simply calling the methods you created above. The game should then loop back to the main menu. If anyone ever chooses “c) shut down game,” which ends the whole program, the high scores should be saved in a NEW .txt file. Keep in mind that as long as the game is up and running, the high scores list should be maintained properly. I highly recommend that you get your game idea approved first so that I can give you a sense of any feasibility issues that may arise. The simplest way to take user input from the console is probably to use java’s built-in Scanner class.

*The final 10% of your grade will be allotted to coding style, documentation/comments, and correctly following submission instructions.*

